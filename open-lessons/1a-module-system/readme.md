# Управление зависимостями в Go: продвинутые техники и корпоративные паттерны
**Продолжительность:** ~1 ч 30 мин

---

## Обзор лекции

- **Цель**:  Погружение в систему модулей Go
- **Аудитория**: Go-разработчики - начинающие и продолжающие
- **Темы**:
  1. Введение и история
  2. Основные правила работы
  3. Версионирование модулей - SIV и MVS

---

## Проблема зависимостей в коде

- мы используем чужой код, он должен как то попасть к вам
- локальная библиотека чужого кода должна быть как то устроена
- может быть много версий чужого кода

---

## От GOPATH к модулям

- **Эра GOPATH**
  - Глобальная рабочая область, сложное управление зависимостями
  - Недетерминированные сборки, общее окружение
- **Причины появления модулей**
  - Локальные, изолированные определения зависимостей
  - Воспроизводимые сборки, чёткое версионирование

---

## Особенности 
  - Явные файлы `go.mod` и `go.sum`
  - Зависимости имеют версию
  - модули в го - это репозтории с исходным кодом.
  - нет скомпилированных зависимостей
  - модули и пакеты

---

## Файл go.mod

- **Структура**
  - Пример: https://github.com/hashicorp/terraform/blob/main/go.mod
  - `module <имя-модуля>`
  - Директивы `require` для зависимостей
  - Опционально: `replace`, `exclude`, `tool`
- **Файл go.sum**
  - Проверка целостности загружаемых модулей
  - Не предназначен для редактирования руками
- **Основные команды**
  - `go mod init` -  инициализирует новый модуль
  - `go mod tidy` - файлы проекта -> go.mod. Плюс форматирование.
  - `go get` - добавляет или обновляет зависимости

---

## Семантическое версионирование (SemVer) в Go

- **Базовое версионирование**
  - Версия хранится в теге гита
  - Распознаются теги вида: major.minor.path: `v1.2.3`
- **Путь импорта для v2+**
  - Необходимо включать номер мажорной версии в путь: `module/v2`

---

## управление зависимостями - Semantic Import Versioning (SIV)

- Работа с мажорными версиями (`module/v2`)
- сохранять обратную совместимость или повышать мажорную версию

---

## управление зависимостями - Транзитивные зависимости

- Для каждого модуля используется только одна версия
- Минимальный выбор версии (MVS)
- 
- выход новых версий модулей не влияет на результат

---

# Вопросы?

---

## go mod vendor

- **Каталог vendor**
  - Команда `go mod vendor` копирует зависимости локально
  - vendor обычно коммитят
- **Плюсы и минусы**
  - Плюсы: 
    - сбороки без доступа к сети
    - скорость сборок
    - проще настраивать CI
  - Минусы: 
    - может разрастаться (но работает умно)
    - требует обновления при смене зависимостей

---

## Модульные прокси и контроль сумм

- **Основы прокси**
  - Прокси по умолчанию: `proxy.golang.org`
  - Кэширует и обеспечивает надёжность загрузки модулей
  - Пользовательские прокси или зеркала для закрытых/корпоративных сетей
- **База данных хеш-сумм** (`sum.golang.org`)
  - Проверяет целостность модулей
  - Защищает от подмены
- **go.sum**
  - Локальная проверка точных версий зависимостей

---

# Вопросы?

---

## Приватные модули и аутентификация

- **Приватные репозитории**
  - https://go.dev/ref/mod#private-modules
  - Использует аутентификацию Git
  - Переменные окружения: `GOPRIVATE` = `GONOPROXY`+`GONOSUMDB`
  - Запросы к приватным репо пропускают публичные прокси
  - Используйте приватный прокси/кэша в крупных компаниях

---

## Проекты, репозитории и модули

- **Сколько репозитариев**
  - Монорепо
  - репо на проект

- **Сколько модулей на репо**
  - один модуль - один репозитарий
  - несколько модулей на репозитарий

---

## Монорепо с одним модулем на все Проекты
- просто начать, надо меньше изучать
- удобно, если у вас деплой разом
- сложнее работать с Git (слишком много всего)
- devOps скрипты версионируются вместе с проектом

---

## Репозитарий на проект. Один модуль в каждом.
- все пути хожены
- зависимости между проектами, версионирование
- PR на несколько репо
- [go.work](https://go.dev/ref/mod#workspaces) 

---

## Несколько модулей на репозиторий
- внимательно - зависимости внутри репо
- `replace`
- go.work?

---

## Практические демонстрации
TODO

1. **Инициализация модуля**
```bash
go mod init github.com/username/demo
go get github.com/pkg/errors
go mod tidy
```

бновление/понижение версий зависимостей
```bash
go get github.com/pkg/errors@v0.9.1
go get github.com/pkg/errors@v0.8.0
```

Использование replace
```bash
replace github.com/pkg/errors => ../local/errors
```

go mod vendor
```bash
go mod vendor
ls vendor/
```
---

## Отладка распространённых проблем

- **Доступ к приватным репозиториям**
  - Если `go mod` жалеутся на доступ, отладьте сначала git pull.
- **Конфликты версий**
  - Изучайте `go.mod` и `go.sum` на предмет несовпадений
  - Используйте `go mod why` / `go mod graph` для поиска конфликтов
- **Несоответствие мажорной версии**
  - `module/v2` случайно импортируется как `module`?
  - Убедитесь в корректном пути импорта в `go.mod` и исходном коде

  - излищнее использование replace

## Основные выводы
 
- Модули дают воспроизводимые сборки и явное управление зависимостями
- Семантическое версионирование – ключ к стабильным релизам
- Прокси, контроль сумм и vendor нужно использовать по ситуации

---

## Дополнительные материалы
- [Официальная документация по модулям Go](https://golang.org/doc/modules)
- [Go Blog: Using Go Modules](https://blog.golang.org/using-go-modules)
- Сообщество, блоги и продвинутые инструменты
https://go.dev/wiki/Modules#semantic-import-versioning
https://go.dev/ref/mod#minimal-version-selection

---