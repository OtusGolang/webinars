.center.icon[![otus main](img/main.png)]

---

class: top white
background-image: url(img/sound.svg)
background-size: 130%
.top.icon[![otus main](img/logo.png)]

.sound-top[
# Как меня слышно и видно?
]

.sound-bottom[
## > Напишите в чат
### **+** если все хорошо
### **-** если есть проблемы cо звуком или с видео
### !проверить запись!
]

---

class: white
background-image: url(img/message.svg)
.top.icon[![otus main](img/logo.png)]

# Кэширование данных

### Автор/Лектор

---

# План занятия

.big-list[

* Для чего нужно кэширование?
* Основные понятия
* Что влияет на принятие решений о кэшировании
* Стратегии кэширования 
* Внешнее хранилище vs локальное кэширование
* Инвалидация кэша
* Алгоритмы вытеснения
* Инструменты 
* Проблемы

  ]


---


.main-image[
![](img/phil.png)
]
.top.icon[![otus main](img/logo.png)]

---

# Для чего нужно кэширование?


* Обслуживание большего количества клиентов с теми же ресурсами благодаря: 
  * переиспользованию ранее полученных или вычисленных данных
  * снижению лишней нагрузки с поставщиков данных

<br>
* Сокращение response time сервисов

<br>
* Стабилизация работы сервисов при пиковых нагрузках

<br>
* Стабилизация работы при кратковременных отказах систем - поставщиков данных



---

# Основные понятия
.big-list[

`Cache miss` - промах кэша - запрошенный ключ не был найден в кэше.

<br>
`Cache Hit` - попадание в кэш - запрошенный ключ найден в кэше.

<br>
`Hit ratio` - процент попаданий запросов в кэш - основной параметр, который характеризует эффективность кэширования:

<br>
    `Hit ratio = Количество попаданий в кэш/Количество запросов`

<br>
`Прогрев кэша` - процесс записи данных в оперативную память приложения или внешнего хранилища кэша.

<br>
`Ключ кэширования` - уникальный идентификатор. Ключ используется для поиска значения.

<br>
`Горячий ключ` - ключ кэширования, на который приходится большая часть запросов на чтение.

<br>
`Инвалидация` - удаление кэшированных объектов.


]

---

# Где применяется

* ###  процессоры
* ###  жесткие диски
* ###  операционные системы
* ###  сети доставки контента (CDN)
* ###  системы DNS
* ###  браузеры
* ###  приложения
* ###  реляционные базы данных
* ###  сервисы кэширования в оперативной памяти

---

# Какие факторы влияют на принятие решений о кэшировании

.main-image[
![](img/trade-off.png)
]
---

# Безопасно ли использовать кэшированное значение?

* Один и тот же фрагмент данных может иметь разные требования к согласованности в разных контекстах.

<br>
>Пример: во время оформления онлайн-заказа необходима актуальная информация о наличии товара, поэтому кэширование может быть проблемой. Но на других страницах интернет - магазина информация о наличии товара может быть устаревшей на несколько минут без негативного влияния на пользователей.

<br>

.main-image[
![](img/you-shall-not-cache.png)
]


---
# Какое допустимое время жизни объектов в кэше?

* Если время жизни объектов в кэше слишком мало, то извлечение данных из основного хранилища и добавление их в кэш будет происходить слишком часто, на это будут уходить лишние ресурсы, а Hit rate будет минимальным.

---

# Допустима ли несогласованность?

* Не все стратегии кэширования гарантируют согласованность данных между основным хранилищем и кэшем. Данные в кэше будут устаревать.

.main-image[
![](img/sitecore-cache-issues.jpg)
]

---

# Вытеснение данных из кэша

* В большинстве случаев кэш имеет меньший объем памяти, чем основное хранилище. При достижении этого размера, часть объектов кэша будут вытесняться.
  Необходимо использовать наиболее оптимальную политику вытеснения.

---

# Эффективность кэша

### Когда кэширование эффективно

* данные из кэша приходят быстрее, чем из основного хранилища
* редкая инвалидация
* небольшое множество горячих ключей
* чтение преобладает над записью


### Что снижает эффективность

* частая инвалидация
* кэширование редко запрашиваемых данных
* недостаточный объем кэша
* неоптимальный выбор алгоритма вытеснения

---

# Стратегии кэширования
* ### Lazy caching
* ### Write-Through
* ### Read-Through
* ### Write-Around

---

# Lazy caching (Ленивое кэширование)

.full-image[
![](img/Lazy.svg)
]

<br>
Приложение сначала идет в кэш.
<br> 
Если данные в нем есть, то возвращает их клиенту. 
<br> 
Если нет - идет в основное хранилище данных, обновляет кэш и отдает данные пользователю.

---
# Lazy caching (Ленивое кэширование)
### `Плюсы`

* Кэш содержит только те объекты, которые действительно запрашивают пользователи.
* Новые объекты добавляются в кэш только по мере необходимости.
* Система устойчива к сбоям кэша. Если кэш недоступен, то приложение может взаимодействовать с источником данных напрямую.

<br>
### `Минусы`

* Каждый промах кэша требует совершить три операции, что может приводить к значительным задержкам.
* Данные записываются напрямую в основное хранилище, что может привести к тому, что в кэше окажутся неактуальные данные. Для решения этой проблемы необходимо предусматривать механизм инвалидации.
---

# Write-through (Сквозная запись)

.main-image[
![](img/write-through.svg)
]

<br>
Данные сначала всегда записываются в кэш. 
<br> 
Затем в основное хранилище данных.
<br> 
Кэш обновляется в реальном времени при обновлении в основном хранилище.

---
# Write-through (Сквозная запись)
### `Плюсы`

* Упрощает процесс обновления кэша. Кэш всегда актуален.
* При достаточном объеме памяти позволяет избежать промахов кэша, что позволяет приложению работать эффективнее и быстрее.
* Долгая запись при обновлении данных, но обеспечивает быстрое чтение.


<br>

### `Минусы`

* Кэш может быть заполнен ненужными объектами, к которым нет запросов, но потребляют лишнюю память. 
* Ненужные объекты могут вытеснять из памяти более нужные.
* Нужен дополнительный механизм, позволяющий заново заполнить кэш при его потере. Комбинирование двух подходов Lazy caching и Write-through решает эту проблему, так как они связаны с противоложными сторонами потоков данных и дополняют друг друга.

---


# Read-Through (Сквозное чтение)

.main-image[
![](img/read-through.svg)
]


<br>
Приложение всегда считывает данные только из кэша. 
<br>
При этом логика наполнения кэша данными выносится в отдельный модуль, например, в крон джобу.



---
# Read-Through (Сквозное чтение)
### `Плюсы`

* Так как приложение читает данные напрямую из кэша и логика записи вынесена в отдельный модуль, логика приложения становится проще.
* Масштабируемость чтения: существует много ситуаций, когда срок действия элемента кэша истекает, и несколько параллельных пользовательских потоков в конечном итоге обращаются к базе данных.
  Сквозное чтение сохраняет ключ в кэше, пока он извлекает его последнюю копию из основного хранилища. Затем он обновляет элемент кэша. В результате приложение никогда не обращается к базе данных за этими элементами кэша, а нагрузка на источник данных сводится к минимуму.

<br>

###  `Минусы`

* Сложность реализации (относительно Lazy caching)

---
# Write-around (Запись в обход)

.main-image[
![](img/write-around.svg)
]

<br>
Если элемент есть в кэше, то при изменении данных он обновляется.
<br>
Если нет, тогда запись происходит только в основное хранилище.

<br>
Этот подход можно комбинировать с другими, например Lazy caching. Это позволит избежать заполнение кэша лишними данными.
---

# Внешнее кэширование или локальное

.main-image[
![](img/external-or-local.svg)
]


---
# Локальное кэширование

### `Плюсы`

* Высокая скорость получения данных.
* Отсутствие сетевых запросов.
* Отсутствие проблем с горячими ключами, которые могут приводить к ассиметричным нагрузкам на шарды внешнего кэша.
* Нет расходов на Marshaling/Unmarshalling данных из кэша.

---

# Локальное кэширование

### `Минусы`

* **Горизонтальное масштабирование сервиса может упереться в производительность сервисов** - источников данных, так как каждый инстанс на старте и по мере устаревания кэша, должен заливать в память кэш.
<br>
Кэширование там, где высокие нагрузки, а значит большое количество инстансов ожидаемо. 

<br>
* **Холодный старт**. Кэш необходимо прогревать при каждом рестарте/редеплое сервиса. Это приводит к росту нагрузки на сервисы - исчтоники данных и может вызвать деградацию response time.

<br>
* Сложная **логика инвалидации** in-memory кэша, обеспечивающая консистентность данных в кэше всех инстансов приложения.


<br>
! Совмещение in-memory кэша и внешнего позволяет решить многие проблемы.

---
# Локальное кэширование

### Когда применять

* Кэширование небольших объемов данных, которые редко изменяются.
  <br>
  `Пример`: справочные значения.

<br>
* Когда основная нагрузка приходится на несколько горячих ключей. 
Разместив их в in-memory кэше можно избежать ассиметричных нагрузок на шарды внешнего кэша.

---
# Внешнее кэширование

<br>
Наиболее распространенная реализация этого типа кэширования основана на базах данных типа «key-value».

.full-image[
![](img/key-value.png)
]

---
# Внешнее кэширование

### `Плюсы`

* данные хранятся централизованно =>
    * прогрев кэша быстрее, чем in-memory
    * проще логика инвалидации, чем in-memory
* может хранить большие объемы данных
* ниже нагрузка на сервисы-источники данных (часто данные достаточно запросить только один раз)
* надежность - можно использовать персистентное хранилище
* масштабирование - внешнее хранилище кэша и сервис, который его использует, масштабируются независимо по мере необходимости

---

# Внешнее кэширование

###  `Минусы`

* Высокие **требования к устойчивости к сбоям**: Потеря существенной части кэшей может привести к полному отказу всей системы. На время прогрева кэша основная нагрузка ляжет на функционал, который может быть не готов к таким нагрузкам.

<br>
* Затраты на **Marshaling/Unmarshalling** кэшируемых данных. Они становятся существенными, если кэшируются большие структуры.

<br>
* Неравномерная нагрузка на шарды кэша - горячие ключи.

<br>
* При изменениях форматов ключей или кэшируемых данных необходимо обеспечивать их совместимость.

---


# Инвалидация

* ### по TTL
* ### обновление кэша при изменении данных
* ### удаление кэша при изменении данных
* ### версионирование
* ### тегирование 

.right-image[
![](img/mmkay.jpg)
]

---

# TTL (Time-to-live)


TTL  — это время, после которого, данные будут удалены из кэша. 
TTL устанавливается при записи объекта в кэш.

<br>
### `Плюсы`:
* Простота реализации
* Выявляет невалидны ключи. Когда обновление или удаление ключа не произошло при обновлении исходных данных в основном хранилище, 
в конечном счете срок действия ключа кэша истечет автоматически, и он будет обновлен (Eventual consistency).


---

# TTL (Time-to-live)

### `Минусы`:
* Неконсистентные данные
* Избыточная инвалидация
* Промахи кэша
* Может стать причиной резкого роста нагрузки на систему:

<br>
Примеры: 

<br>
    1) При постоянном использовании одной и той же длины TTL, срок действия многих ключей кэша может истечь в один момент времени.
      Одно из решений этой проблемы - добавить случайность к TTL: +/- 2 min.

<br>
    2) Миллионы людей подписаны на популярного пользователя в соцсети. Этот пользователь не обновлял свой профиль и не публиковал никаких новых сообщений, но срок действия кэша его профиля истек из-за TTL.
      В этот момент основное хранилище данных может оказаться перегружено идентичными запросами.

---

# Обновление кэша при изменении данных

* Применяется в стратегии кэширования Write-through.

### `Плюсы`:
* Консистентные данные
* Нет избыточной инвалидации

### `Минусы`:
* Сложность реализации
* Увеличивает время записи
* Невалидные ключи могут долго не выявляться

---
# Инвалидация кэша при изменении данных

* При изменении данных кэш только удаляется. Запись в кэш происходит позже, например, при первом запросе данных.

### `Плюсы`:

* Время записи
* Простота реализации
* Консистентные данные

### `Минусы`:
* Промахи кэша
* Невалидные ключи могут долго не выявляться

---

# Версионирование ключа кэширования

* Обычно сочетается с другими подходами инвалидации и может применяться для инвалидации ключей когда между ними отсутствуют зависимости. 
Например, при массовом попадании в кэш невалидных данных,

<br>
К ключу кэширования добавляется версия:

<br>

`{id}_seller_v1`

<br>
Для инвалидации всех ключей кэширования с префиксом `seller` достаточно инкрементировать версию ключа.
 

---

# Тегированный кэш

Применяется в сочетании с другими подходами инвалидации, когда между ключами есть зависимости.
<br>
Нужно отразить зависимости в кэше, чтобы сразу выполнять инвалидацию группы элементов.

<br>
`Реализация`:

<br>
Вместе с данными сохраняется текущая версия тега, от которого зависят эти данные.

<br>
**Группа кэшей** - это кэши, имеющие один общий тэг.

<br>
Чтобы сбросить группу кэшей, достаточно инкрементировать версию соответствующего тэга.
При обновлении данных генерируется новая версия тега.

---

# Тегированный кэш

.center-image[
![](img/tag1.png)
]

---
# Тегированный кэш

.center-image[
![](img/tag2.png)
]

---

# Алгоритмы замещения данных в кэше

**Алгоритм замещения** - алгоритм, определяющий порядок удаления объектов из кэш-памяти и записи на их место новых данных.

<br>
**Оптимальный алгоритм** должен выбирать для замещения элемент, обращение к которому не ожидается в будущем дольше других.

<br>
Выбор алгоритма кэша зависит от того, как будет использоваться память, от последовательности, периодичности, частоты запросов.

---

# Алгоритмы замещения данных в кэше

.main-image[
![](img/lru-lfu.webp)
]

---

# Алгоритмы замещения данных в кэше

.main-image[
![](img/algorithms-hierarchy.png)
]

---

# Алгоритмы замещения данных в кэше


### 1. LRU (Least Recently Used)
### 2. LFU (Least frequently used)
### 3. SLRU (Segmented LRU)
### 4. LIFO (Last in first out)
### 5. FIFO (First in first out)
### 6. 2Q (2 queue)
### 7. MQ (Multi queue)

---

# LRU (Least Recently Used)

.main-image[
![](img/LRU.svg)
]

---
# LRU (Least Recently Used)

`Least Recently Used` - каждый новый элемент вставляется в голову списка. При запросе элемента он перемещается в голову списка вытесняя оттуда старый элемент.
Если нужно освободить место, вытесняется элемент из хвоста списка.

<br>
`Минусы`

<br>
LRU кэш может быть заполнен элементами, которые были запрошены только один раз, таким образом из памяти исключаются ключи, которые запрашивали чаще.
<br>
Этот алгоритм применяется, если данные, к которым недавно обращались, скорее всего, вскоре понадобятся повторно. 
<br>
Если к данным обращаются по расписанию в запланированное время, например при циклическом сканировании, LRU не подойдет.

---
# LFU (Least frequently used)

.main-image[
![](img/LFU-1.svg)
]

---

# LFU (Least frequently used)

### get(E)

.main-image[
![](img/LFU-2.svg)
]

---

# LFU (Least frequently used)

`Least frequently used` - данный алгоритм подсчитывает частоту запросов каждого элемента кэша и вытесняет тот элемент, к которому обращались меньше всего раз.

---
# SLRU (Segmented LRU)

.main-image[
![](img/SLRU.svg)
]

---

# SLRU (Segmented LRU)

`Segmented Least Recently Used` - модернизированная версия обычного LRU.

<br>
Кэш разделен на два сегмента: "испытательный" и защищенный сегмент. Может быть добавлен сегмент для наименее активных объектов.

<br>
При первом запросе значение попадает в первый сегмент, при повтороном запросе элемент перекладывается во второй.

<br>
Этот метод позволяет избежать переполнения кэша данными, которые не будут использоваться повторно, потому что защищенный сегмент содержит элементы, к которым обращались не менее двух раз.

---

# LIFO (Last in first out)

`Last in first out` - из кэша вытесняется элемент, добавленный самым последним, независимо от того, как часто или сколько раз он был запрошен.

---

# FIFO (First in first out)

`First in first out` - из кэша удаляются элементы в том же порядке, в котором они были добавлены, независимо от того, как часто или сколько раз они были запрошены.

---

# 2Q (2 queue)

.main-image[
![](img/2Q.svg)
]

---
# 2Q (2 queue)

`2 queue` - в алгоритме две очереди. Кэш разделяется на части, как в сегментированном LRU.

<br>
Первая очередь содержит новые элементы и работает как очередь FIFO. Она поделена на две очереди: In и Out.

<br>
Элементы запрошенные из In никуда не двигаются. При вытеснении из In элементы перемещаются в Out.

<br>
Элементы запрошенные из Out — попадают в LRU очередь. Вытесненные элементы из Out (не запрошенные) — удаляются.

<br>
https://www.vldb.org/conf/1994/P439.PDF

---

# MQ (Multi queue)

`Multi Queue` - вариация LRU кэша. 

<br>
Этот алгоритм содержит несколько очередей, где объекты расположены по рейтингу.  Каждый список построен по принципу LRU.

<br>
Для каждого объекта ведётся счётчик его запросов (LFU).
Алгоритм уменьшает рейтинг объекта, чтобы в конечном счете вытеснить объекты, к которым обращались часто в прошлом, но не запрашивали в течение длительного времени.

<br>
Чтобы в кэше не висели ранее популярные элементы, к которым больше нет запросов, в MQ ля каждого элемента введено понятие 
`expiredTime = currentTime + lifeTime`.
<br>
При каждом запросе проверяется условие `currentTime > expiredTime` и если оно выполняется, то элемент перемещается в начало нижележащего списка(если ниже спускаться некуда,
то перемещается в конец текущего списка)

<br>
https://www.usenix.org/legacy/event/usenix01/full_papers/zhou/zhou.pdf


---
# Инструменты кэширования

### Локальное:
* ### Map
* ### ristretto

### Внешнее:
* ### redis
* ### memcached
* ### couchbase
* ### etcd
* ### hazelcast

---
# Локальное кэширование

### https://pkg.go.dev/sync#Map

### https://github.com/dgraph-io/ristretto

---
# Сравнение инструментов внешнего кэширования

.center-image[
![](img/table.svg)
]

---

# Внешнее кэширование

### redis: https://redis.io/
### memcached: https://memcached.org/
### couchbase: https://docs.couchbase.com/
### etcd: https://etcd.io/
### hazelcast: https://hazelcast.com/

Ещё больше сравнение характеристик 
https://db-engines.com/en/system/Couchbase%3BHazelcast%3BMemcached%3BRedis%3Betcd

<br>
DB Ranking:  https://db-engines.com/en/ranking_trend

---

# Внешнее кэширование

.main-image[
![](img/persist.svg)
]

---

# Проблемы

.right-image[
![](img/not-sure.png)
]
---

# The thundering herd problem


### Эффект "стаи собак"

<br>
Это резкий рост нагрузки на систему, который возникает, когда множество различных процессов приложения (или запросов) одновременно запрашивают один ключ кэша, получают cache miss, а затем каждый из них параллельно выполняет один и тот же запрос к базе данных.
И чем дороже этот запрос, тем большее влияние он оказывает на базу данных.

<br>
> Примеры:

<br>
- Старт распродажи в интернет магазине в Черную пятницу.
- Истечение срока действия кэша (TTL) популярного товара на маркетплейсе.
- Добавление нового шарда кэша: его память пуста и механизм ребалансировки начинает заполнять её.

---

# The thundering herd problem

### Решения:

* ### предварительный прогрев кэша

* ### отдавать истекшие данные

  * приложение берет на себя ответственность за обновление ключа по TTL
  * кладем в кэш время истечения ключа
  * при чтении приложение проверяет TTL ключа
  * если TTL истек, приложение продлевает его ещё на небольшой срок
  * в это время идет за актуальными данными и обновлет кэш

<br>

>Этот способ позволяет снять существенный % запросов, но не гарантирует только 1 запрос в основное хранилище.


---

# Неравномерное распределение данных 

.main-image[
![](img/sharding.svg)
]

Для повышения надежности и производительности системы кэширования ее делят на несколько шардов. 

---

# Неравномерное распределение данных 

### Как равномерно делить данные между ними?

<br>

1) **Хеширование ключей** - данные разделяются по серверам в зависимости от ключа кэширования. Для этого используется хеш функция, которая на вход принимает ключ и возвращает номер сервера.

<br>
https://github.com/serialx/hashring

<br>
`Минусы`:
* в случае добавления новых шардов кэшей из-за ребалансировки ключей теряются данные
* хеширование не поможет, если большой процент операций чтения/записи приходится на один ключ

<br>

2) Если известно, что один конкретный ключ - горячий, то можно добавить в начало или конец этого ключа случайное число из заданного диапазона.

<br>
Простое двузначное число из диапазона 0 - 99 позволит равномерно распределить операции записи и чтения по 100 разным ключам и распределить их по разным шардам.
  Этот подход имеет смысл только для небольшого числа горячих ключей.


---
class: white
background-image: url(img/message.svg)
.top.icon[![otus main](img/logo.png)]

# Спасибо за внимание!
